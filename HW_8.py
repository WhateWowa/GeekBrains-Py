# 1. Реализовать класс «Дата», функция-конструктор которого должна принимать дату в виде строки формата «день-месяц-год».
# В рамках класса реализовать два метода. Первый, с декоратором @classmethod, должен извлекать число, месяц, год
# и преобразовывать их тип к типу «Число». Второй, с декоратором @staticmethod, должен проводить валидацию
# числа, месяца и года (например, месяц — от 1 до 12). Проверить работу полученной структуры на реальных данных.

# class Date:
#     def __init__(self, date, month, year):
#         self.date = date
#         self.month = month
#         self.year = year
#         self.print = print('День: ', date, 'Месяц: ',month, 'Год: ',year)
#
#     @classmethod
#     def unzip_use(cls):
#         print('Date is: ', (self.date), '-', (self.month), '-', (cls.year))
#
#     @staticmethod
#     def validation(date, month, year=None):
#         if date in range(1, 31):
#             print('Дата: ', date)
#         else:
#             print('Число вне диапазона 1-31')
#
#         if month in range(1, 13):
#             print('Месяц: ', month)
#         else:
#             print('Месяц должен быть от 1 до 12')
#
#         try:
#             while True:
#                 if year is None:
#                     pass
#                 else:
#                     if year is int(year):
#                         print('Год: ', int(year))
#                         break
#         except ValueError:
#             print('Неверный формат даты')
#
# дата = Date(19, 2, 1989)
# дата.print
# дата.validation(32, 15, 'тыщастопятый')
# Date.unzip(24, 10, 1964)

# 2. Создайте собственный класс-исключение, обрабатывающий ситуацию деления на нуль. Проверьте его работу на данных,
# вводимых пользователем. При вводе пользователем нуля в качестве делителя программа должна корректно обработать
# эту ситуацию и не завершиться с ошибкой.

# class ZeroNull(Exception):
#     def __init__(self, txt):
#         self.txt = txt
#
# a = input('Введите знаменатель: ')
#
# try:
#     a = int(a)
#     if a > 0 or a < 0:
#         print(100 / a)
#     else:
#         raise ZeroNull('На ноль делить нельзя!')
# except ValueError:
#     print('Вы ввели не число!')
# except ZeroNull as zn:
#     print(zn)


# 3. Создайте собственный класс-исключение, который должен проверять содержимое списка на наличие только чисел.
# Проверить работу исключения на реальном примере. Необходимо запрашивать у пользователя данные и заполнять список.
# Класс-исключение должен контролировать типы данных элементов списка.
# Примечание: длина списка не фиксирована. Элементы запрашиваются бесконечно, пока пользователь сам не остановит
# работу скрипта, введя, например, команду “stop”. При этом скрипт завершается, сформированный список выводится на экран.
# Подсказка: для данного задания примем, что пользователь может вводить только числа и строки.
# При вводе пользователем очередного элемента необходимо реализовать проверку типа элемента и вносить его в список,
# только если введено число. Класс-исключение должен не позволить пользователю ввести текст (не число) и отобразить
# соответствующее сообщение. При этом работа скрипта не должна завершаться.

# class Numbers(Exception):
#     def __init__(self, txt):
#         self.txt = txt
#
# my_list = []
#
# while True:
#     try:
#         input_date = str(input('Вводите числа, каждое число подтверждайте кнопкой "Enter": '))
#         if str(input_date) == "stop":
#             print(my_list)
#             break
#         if type(int(input_date)) is int:
#             my_list.append(input_date)
#         else:
#             if int(input_date) == 0:
#                 raise Numbers('Введите отличное от нуля число!')
#     except ValueError:
#         print('Введите число!')
#     except Numbers as ns:
#         print(ns)
# else:
#     pass

# 4. Начните работу над проектом «Склад оргтехники». Создайте класс, описывающий склад. А также класс «Оргтехника»,
# который будет базовым для классов-наследников. Эти классы — конкретные типы оргтехники (принтер, сканер, ксерокс).
# В базовом классе определить параметры, общие для приведенных типов. В классах-наследниках реализовать параметры,
# уникальные для каждого типа оргтехники.

# class OrgTech:
#     def __init__(self, name, quanity):
#         self.name = name
#         self.quanity = quanity
#
#     def __str__(self):
#         return self.name + ' ' + self.quanity
#
# class Suplay(OrgTech):
#     def __init__(self, cell):
#         self.cell = cell
#         self.sup_dict = {}
#
#     def to_sup(self, subj):
#         self.subjects_dict.append(subj)
#
# class Printer(OrgTech):
#     def printer(self):
#         print('Printing...')
#
# class Scaner(OrgTech):
#     def scaner(self):
#         print('Scaning...')
#
# class Xerox(OrgTech):
#     def xerox(self):
#         print('Xeroxing...')

# 5. Продолжить работу над первым заданием. Разработать методы, отвечающие за приём оргтехники на склад
# и передачу в определенное подразделение компании. Для хранения данных о наименовании и количестве единиц оргтехники,
# а также других данных, можно использовать любую подходящую структуру, например словарь.

# My_sup = {'№: ': 1, 'Name: ': 'Xerox', 'Quanity:': 3, 'Otdel: ': 'Ne tvoih del'}
# print(My_sup.keys())
# print(My_sup.values())
# каким образом оформить запись в список, новые записи из словаря?

# 6. Продолжить работу над вторым заданием. Реализуйте механизм валидации вводимых пользователем данных.
# Например, для указания количества принтеров, отправленных на склад, нельзя использовать строковый тип данных.
# Подсказка: постарайтесь по возможности реализовать в проекте «Склад оргтехники» максимум возможностей,
# изученных на уроках по ООП.

# проверка вводимых данных через if type()
#                                     else:

# 7. Реализовать проект «Операции с комплексными числами». Создайте класс «Комплексное число»,
# реализуйте перегрузку методов сложения и умножения комплексных чисел. Проверьте работу проекта,
# создав экземпляры класса (комплексные числа) и выполнив сложение и умножение созданных экземпляров.
# Проверьте корректность полученного результата.

# class Compleks(object):
#
#     def testruner(self, i=None, o=None):
#         if isinstance(i, complex):
#             print('Real :', i.real, 'Img: ', i.imag)
#         if isinstance(o, complex):
#             print('Real :', o.real, 'Img: ', o.imag)
#         else:
#             pass
#
#     def sumruner(self, i=None, o=None):
#         if isinstance(i and o, complex):
#             s = i + o
#             print('Sum: ', s)
#         else:
#             pass
#
#     def multirunner(self, i=None, o=None):
#         if isinstance(i and o, complex):
#             m = i * o
#             print('Mul: ', m)
#         else:
#             pass
#
# x = Compleks()
# x.testruner(1 + 2j, 3 + 4j)
# x.sumruner(1 + 2j, 3 + 4j)
# x.multirunner(1 + 2j, 3 + 4j)